#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
//layout(local_size_variable) in;

layout(binding = 0, rgba8, set = 0) uniform image2D albedoImage;
layout(binding = 1, rgba8_snorm, set = 0) uniform image2D worldNormalImage;
layout(binding = 2, r32f, set = 0) uniform image2D depthImage;
layout(binding = 3, std140, set = 0) uniform cameraTransformations
{
    mat4 viewInverse;
    mat4 projInverse;
    vec3 rayOrigin;
};
layout(binding = 4) uniform lightInformation
{
    vec3 lightPosition;
};

layout(binding = 5, rgba8) uniform image2D outputImage;

void main() {
    ivec2 pixel = ivec2(gl_WorkGroupID.xy);
    vec4 albedo = imageLoad(albedoImage, pixel);
    vec3 worldNormal = normalize(imageLoad(worldNormalImage, pixel).xyz);
    float depth = imageLoad(depthImage, pixel).x;

    // get uv
    vec2 uv = 2.0 * vec2(gl_WorkGroupID.xy) / vec2(gl_NumWorkGroups.xy) - vec2(1.0);
    uv.x = -uv.x;

    // get world position
    vec4 worldPosition4 = viewInverse * projInverse * vec4(uv, depth, 1.0);
    vec3 worldPosition = worldPosition4.xyz / worldPosition4.w;

    // diffuse
    vec3 lightDir = normalize(lightPosition - worldPosition);
    float diffuseIntensity = clamp(dot(worldNormal, lightDir), 0.0, 1.0);

    // fake specular for test
    vec3 eyeDir = normalize(rayOrigin - worldPosition);
    float specular = pow(clamp(dot(reflect(-lightDir, worldNormal), eyeDir), 0.0, 1.0), 16.0);
    const vec4 specularColor = vec4(1.0, 1.0, 1.0, 0.0);

    // sum everything
    vec4 outColor = (diffuseIntensity * albedo) + (specular * specularColor);

    // store
    imageStore(outputImage, pixel, outColor);
}