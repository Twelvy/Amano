// Ray generation shader
// computes the shadow
#version 460
#extension GL_NV_ray_tracing : require

layout(location = 0) rayPayloadNV float payload;
layout(binding = 0, set = 0) uniform accelerationStructureNV acc;
layout(binding = 1, r8) uniform image2D accumulationBuffer;
layout(binding = 2, rgba8) uniform image2D outputImage;
layout(binding = 3, std140, set = 0) uniform rayParams
{
    mat4 viewInverse;
    mat4 projInverse;
    vec3 rayOrigin;
};
layout(binding = 4, r32f, set = 0) uniform image2D depthImg;
layout(binding = 5, rgba8_snorm, set = 0) uniform image2D worldNormalImg;
layout(binding = 6, rgba8, set = 0) uniform image2D colorImg;
layout(binding = 7, std140, set = 0) uniform lightInformation
{
    vec3 lightPosition;
    float prevFrameWeight;
    vec3 lightOffset;
};

float getLightIntensity(vec3 origin, vec3 target, vec3 normal) {
    vec3 direction = target - origin;
    float lightIntensity = 0.0f;
    if (dot(normal, direction) > 0.0) {
        payload = 1.0f;
        float maxLength = length(direction);
        traceNV(acc,
                gl_RayFlagsOpaqueNV | gl_RayFlagsTerminateOnFirstHitNV,
                0xff,
                0,
                0,
                0,
                origin,
                0.001,
                normalize(direction),
                maxLength,
                0);
        lightIntensity = payload;
    }
    return lightIntensity;
}

void main() {
    const vec2 pixel = vec2(gl_LaunchIDNV.x + 0.5, gl_LaunchIDNV.y + 0.5);
    const vec2 clipPos = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;
    const float depth = imageLoad(depthImg, ivec2(gl_LaunchIDNV)).x;

    float lightIntensity = 1.0;

    if (depth > 0.0 && depth < 1.0) {
        const vec3 worldNormal = imageLoad(worldNormalImg, ivec2(gl_LaunchIDNV)).xyz;
        vec4 worldPosition = viewInverse * projInverse * vec4(clipPos.xy, depth, 1.0);
        vec3 origin = worldPosition.xyz / worldPosition.w;
        lightIntensity = getLightIntensity(origin, lightPosition + lightOffset, worldNormal);
    }

    if (prevFrameWeight != 0.0) {
        float previousIntensity = imageLoad(accumulationBuffer, ivec2(gl_LaunchIDNV)).r;
        lightIntensity = (lightIntensity + prevFrameWeight * previousIntensity) / (prevFrameWeight + 1.0);
    }
    imageStore(accumulationBuffer, ivec2(gl_LaunchIDNV), vec4(lightIntensity));
    vec4 color = imageLoad(colorImg, ivec2(gl_LaunchIDNV));
    imageStore(outputImage, ivec2(gl_LaunchIDNV), lightIntensity * color);
}
